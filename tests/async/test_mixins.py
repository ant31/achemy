"""
Tests for achemy/mixins.py
"""
import asyncio
import uuid
from datetime import datetime, timedelta

import pytest

# Use the setup fixture defined in async/conftest.py
# pytestmark = pytest.mark.usefixtures("setup_mixin_tests")
# Note: Tests rely on unique_id for isolation instead of table cleaning.


@pytest.mark.asyncio
async def test_pkmixin_id_creation(
    setup_mixin_tests, mock_pk_model_class, unique_id
): # setup_mixin_tests no longer depends on aclean_tables
    """Test that PKMixin creates a UUID id."""
    instance = mock_pk_model_class(name=f"pk_test_{unique_id}")
    # ID should be generated by default_factory on init
    assert isinstance(instance.id, uuid.UUID)
    # Save to ensure server_default also works (though harder to test exact value)
    async with mock_pk_model_class.get_session() as s:
        await instance.save(s, commit=True)

    assert isinstance(instance.id, uuid.UUID)


@pytest.mark.asyncio
async def test_pkmixin_find(setup_mixin_tests, mock_pk_model_class, unique_id):
    """Test the find classmethod of PKMixin."""
    instance_name = f"find_test_{unique_id}"
    async with mock_pk_model_class.get_session() as s:
        instance = await mock_pk_model_class(name=instance_name).save(s, commit=True)
        found_instance = await mock_pk_model_class.find(s, instance.id)
        assert found_instance is not None
        assert found_instance.id == instance.id
        assert found_instance.name == instance_name

        # Test find non-existent
        non_existent_uuid = uuid.uuid4()
        not_found_instance = await mock_pk_model_class.find(s, non_existent_uuid)
        assert not_found_instance is None


@pytest.mark.asyncio
async def test_updatemixin_timestamps(setup_mixin_tests, mock_update_model_class, mock_combined_model_class, unique_id):
    """Test that UpdateMixin adds and manages timestamps."""
    # start_time = datetime.now(UTC) # Removed unused variable
    await asyncio.sleep(0.01) # Ensure time progresses slightly

    instance_name = f"timestamp_test_{unique_id}"
    instance = mock_combined_model_class(name=instance_name)

    # Timestamps should not be set before save
    # Note: MappedAsDataclass might initialize them depending on exact setup,
    # but they should be overwritten by server_default on save.
    # Let's check after save.
    async with mock_update_model_class.get_session() as session:
        instance = await instance.save(session, commit=True)

        await asyncio.sleep(0.01)
        # end_time = datetime.now(UTC) # Removed unused variable

        assert isinstance(instance.created_at, datetime)
        assert isinstance(instance.updated_at, datetime)
        # Initially, created_at and updated_at should be very close
        assert abs(instance.updated_at - instance.created_at) < timedelta(seconds=1)

        # Test onupdate
        created_at_before_update = instance.created_at
        updated_at_before_update = instance.updated_at

        await asyncio.sleep(0.05)  # Ensure updated_at changes significantly
        instance.name = f"timestamp_test_updated_{unique_id}"
        instance = await instance.save(session, commit=True)


        assert instance.created_at == created_at_before_update # created_at should not change
        assert instance.updated_at > updated_at_before_update
        assert instance.updated_at > instance.created_at
        #assert instance.updated_at > start_time + timedelta(seconds=0.05)


@pytest.mark.asyncio
async def test_updatemixin_queries(setup_mixin_tests, mock_combined_model_class, unique_id):
    """Test timestamp-baed query methods of UpdateMixin."""
    Model = mock_combined_model_class
    async with mock_combined_model_class.get_session() as session:
        # Create instances with varying timestamps
        # Removed sleeps - rely on transaction commit order for timestamps
        instance1 = await Model(name=f"q_old_{unique_id}").save(session, commit=True)
        instance2 = await Model(name=f"q_mid_{unique_id}").save(session, commit=True)
        instance3 = await Model(name=f"q_new_{unique_id}").save(session, commit=True)

        # Update instance2 - ensure this happens distinctly after creation
        # A small sleep might still be needed if DB timestamp resolution is low,
        # but let's try without first. If tests become flaky, add a minimal sleep back here.
        # await asyncio.sleep(0.01) # Potential minimal sleep if needed
        instance2.name = f"q_mid_updated_{unique_id}"
        instance2 = await instance2.save(session, commit=True)

        # --- Test last_created ---
        # Need to filter queries to this test's data
        query_lc = Model.select().where(Model.name.like(f"%_{unique_id}"))
        # last_created = await Model.last_created(session) # Pass session explicitly
        # Original call might fetch unrelated data from other tests
        # Re-query with filter to ensure we get the one from *this* test run
        last_created_filtered = await Model.first(session, query=query_lc.order_by(Model.created_at.desc()))
        assert last_created_filtered is not None
        assert last_created_filtered.id == instance3.id  # instance3 was created last in this batch

        # --- Test first_created ---
        query_fc = Model.select().where(Model.name.like(f"%_{unique_id}"))
        first_created_filtered = await Model.first(session, query=query_fc.order_by(Model.created_at.asc()))
        assert first_created_filtered is not None
        assert first_created_filtered.id == instance1.id  # instance1 was created first in this batch

        # --- Test last_modified ---
        query_lm = Model.select().where(Model.name.like(f"%_{unique_id}"))
        last_modified_filtered = await Model.first(session, query=query_lm.order_by(Model.updated_at.desc()))
        assert last_modified_filtered is not None
        # instance2 was updated most recently in this batch
        assert last_modified_filtered.id == instance2.id

        # --- Test get_since ---
        # Filter the base query for get_since
        query_gs = Model.select().where(Model.name.like(f"%_{unique_id}"))

        # Get records modified after instance1 was created (within this test's data)
        since_time1 = instance1.updated_at  # Use updated_at as modification time
        modified_since_1 = await Model.get_since(session, since_time1, query=query_gs)
        # Should include instance2 (updated) and instance3 (created) from this batch
        assert len(modified_since_1) == 2
        modified_ids = {m.id for m in modified_since_1}
        assert instance2.id in modified_ids
        assert instance3.id in modified_ids

        # Get records modified after instance3 was created but before instance2 was updated
        since_time3 = instance3.updated_at
        modified_since_3 = await Model.get_since(session, since_time3, query=query_gs)
        # Should include only instance2 (which was updated after instance3 creation) from this batch
        assert len(modified_since_3) == 1
        assert modified_since_3[0].id == instance2.id

        # Get records modified after instance2 was updated
        since_update_time = instance2.updated_at
        modified_since_update = await Model.get_since(session, since_update_time, query=query_gs)
        # Should include none from this batch, as nothing was modified after instance2's update
        assert len(modified_since_update) == 0
